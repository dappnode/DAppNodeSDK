import { CommandModule } from "yargs";
import { CliGlobalOptions } from "../../../types";
import { defaultDir } from "../../../params";
import { getGithubContext } from "../../../providers/github/githubActions";
import { buildHandler } from "../../build";
import { Github } from "../../../providers/github/Github";
import { parseRef } from "../../../providers/github/utils";
import { getBuildBotComment, isTargetComment } from "./botComment";
import { cleanPinsFromDeletedBranches } from "./cleanPinsFromDeletedBranches";

// This action should be run on 'push' and 'pull_request' events
//
// For 'push' events ('branch'):
//   Does a build test and uploads release to Pinata tagged with branch
//   and commit. It will also locate any PRs from that branch and comment
//   the resulting hash, so it can be used by testers.
//   Another job 'unpin-on-ref-delete' should delete eventually the
//   releases generated by this action
//
// For 'push' events ('tags'):
//   Skip for now. On 'tag' another action should publish instead of just
//   building, maybe it can be done by this job, but consider alternatives
//
// For 'pull_request' events:
//   Does a build test but doesn't upload the result anywhere

export const gaBuild: CommandModule<CliGlobalOptions, CliGlobalOptions> = {
  command: "build",
  describe:
    "Build and upload test release and post a comment with install link to the triggering PR",
  builder: {},
  handler: async (args): Promise<void> => await gaBuildHandler(args)
};

/**
 * Common handler for CLI and programatic usage
 */
export async function gaBuildHandler({
  dir = defaultDir
}: CliGlobalOptions): Promise<void> {
  const { eventName, sha: commitSha, ref: refString } = getGithubContext();
  const ref = parseRef(refString);

  // Clean pins that were added from past runs.
  // Doing it here prevents having to add two workflows per repo.
  // Also, ensures that pins are deleted eventually, even if this fails sometimes
  try {
    await cleanPinsFromDeletedBranches({ dir });
  } catch (e) {
    console.error("Error on cleanPinsFromDeletedBranches", e);
  }

  if (
    eventName === "push" &&
    ref.type === "branch" &&
    // Do not upload to pinata for branches that are never deleted
    ref.branch !== "HEAD" &&
    ref.branch !== "master" &&
    ref.branch !== "main"
  ) {
    await buildAndComment({
      dir,
      commitSha,
      branch: ref.branch
    });
  } else if (eventName === "push" || eventName === "pull_request") {
    // Consider that for 'pull_request' commitSha does not represent a known commit
    // The incoming branch is merged into the target branch and the resulting
    // new commit is tested. gitHead() will return 'HEAD' for branch and a foreign commit
    // Pinata example: 'dappnodesdk.public HEAD 2f149cf'
    // See https://github.community/t/github-sha-not-the-same-as-the-triggering-commit/18286

    // By default just do a test build and skip_save
    await buildHandler({
      provider: "dappnode",
      upload_to: "ipfs",
      skip_save: true,
      verbose: true
    });
  } else if (!eventName) {
    throw Error("Not in Github action context");
  } else {
    throw Error(`Unsupported event ${eventName}`);
  }
}

export async function buildAndComment({
  dir,
  commitSha,
  branch
}: {
  dir: string;
  commitSha: string;
  branch: string;
}): Promise<void> {
  // Connect to Github Octokit REST API and post or edit a comment on PR
  const github = Github.fromLocal(dir);

  const { releaseMultiHash } = await buildHandler({
    provider: "pinata",
    upload_to: "ipfs",
    require_git_data: true,
    delete_old_pins: true,
    verbose: true
  });

  const body = getBuildBotComment({ commitSha, releaseMultiHash });
  console.log(`Build bot comment: \n\n${body}`);

  const prs = await github.getOpenPrsFromBranch({ branch });
  console.log(`
    Repo: ${github.repoSlug}
    Branch ${branch}
    PRs: ${prs.map(pr => pr.number).join(", ")}
  `);

  await Promise.all(
    prs.map(pr =>
      github.commentToPr({ number: pr.number, body, isTargetComment })
    )
  );
}
